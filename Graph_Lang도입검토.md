# Graph/Lang 도입 검토 (doc_rag)

기준일: 2026-02-25  
검토 입력 원문: `통합graph_lang설명.md`  
대상 시스템: `doc_rag` (로컬/경량 RAG 런타임)

## 1) 원문 제안 아키텍처 요약

`통합graph_lang설명.md`에서 제시한 핵심은 다음 3가지다.

1. 지식 적재 이원화
- Contextual Retrieval 기반 청킹/맥락 보강
- Vector Store + Graph DB(Neo4j) 동시 저장

2. 검색/생성 오케스트레이션
- LangGraph Orchestrator + Query Router
- Hybrid Search(Vector + Graph) + Re-ranker

3. 운영 관측
- LangSmith 기반 Trace/Eval

즉, "기존 문서 RAG + 관계형 지식 질의"를 결합한 하이브리드 구조다.

## 2) 현재 doc_rag 대비 적합성

현재 `doc_rag` 강점:
- FastAPI 단일 서비스
- Chroma 기반 경량 벡터 검색
- 컬렉션 라우팅/검증/승인 워크플로우(P1 완료)

원문 구조 도입 시 추가되는 무게:
- Graph 추출 파이프라인(Entity/Relationship)
- Graph DB 운영(Neo4j)
- LangGraph 런타임 상태 관리
- Re-ranker 및 추적 인프라(LangSmith)

판단:
- 기능 가치(복합 관계 질의 정확도)는 높음
- 하지만 현재 프로젝트 목표(로컬, 경량, 안정적 운영)와 정면충돌 가능성이 큼

## 3) 도입 방식 비교

### A. 본체 직접 통합 (in-process)
장점:
- 단일 배포 경로
- 내부 호출이라 홉 감소

단점:
- `app_api.py` 복잡도 급증
- 장애 격리 실패 가능성 증가
- p95/p99 지연 변동성 확대
- 현재 운영 모델(가벼운 런타임) 훼손

### B. 사이드카 분리 (권장)
장점:
- 기존 `/query` 경로 안정성 보존
- Graph/Lang 실험/롤백이 쉬움
- 단계적 활성화 가능(특정 질의만 라우팅)
- 성능 문제 발생 시 본체 영향 최소화

단점:
- 프로세스/서비스 1개 추가 운영
- 초기 통합 포인트(API 계약, 타임아웃, 장애 fallback) 정의 필요

## 4) 성능 관점 결론

원문 아키텍처는 검색 품질 측면에서 강점이 크지만, 연산 단계가 늘어 지연·복잡도가 상승한다.

`doc_rag` 성격(로컬/경량/폐쇄망) 기준 최적 결론:
- 기본 경로는 기존 Vector RAG 유지
- Graph/Lang은 **사이드카 방식**으로 선택적 적용

즉, "기본은 빠르고 단순하게, 고급 질의만 Graph/Lang으로"가 맞다.

## 5) 권장 실행안

1. Phase 1: 계약 정의
- 본체 ↔ 사이드카 API 스펙 정의(`/query-advanced` 등)
- 타임아웃/실패 fallback 규칙 정의(실패 시 본체 Vector 경로로 자동 전환)

2. Phase 2: 최소 기능 PoC
- Query Router + Hybrid Search 최소 구현
- 10~20개 대표 질의셋으로 정확도/지연 비교

3. Phase 3: 선택적 운영
- 관리자 설정에서 "고급 추론 모드" ON 시만 사이드카 호출
- 기본 모드는 항상 기존 `/query`

4. Phase 4: 확대 여부 결정
- 기준 충족 시(정확도 개선 + 지연 허용 범위) 점진 확대
- 미충족 시 사이드카 유지/보류

## 6) 수용 기준(권장)

- 정확도: 관계형 질의 정답률이 기존 대비 유의미하게 개선
- 지연: 사이드카 모드 p95가 운영 허용치를 넘지 않음
- 안정성: 사이드카 장애 시 본체 질의 기능 영향 없음
- 운영성: 재색인/요청승인/컬렉션 정책과 충돌 없음

## 7) 최종 권고

`통합graph_lang설명.md`의 방향은 전략적으로 타당하다.  
다만 `doc_rag`에는 **직접 통합이 아니라 사이드카 방식**으로 도입하는 것이 프로젝트 성격과 성능 목표에 가장 적합하다.
